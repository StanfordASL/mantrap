
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <title>Agents &#8212; mantrap 0.1 documentation</title>
    <link rel="stylesheet" href="_static/pyramid.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Environment" href="environment.html" />
    <link rel="prev" title="mantrap" href="index.html" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Neuton&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Nobile:regular,italic,bold,bolditalic&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

  </head><body>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="environment.html" title="Environment"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="index.html" title="mantrap"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">mantrap 0.1 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="agents">
<h1>Agents<a class="headerlink" href="#agents" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-mantrap.agents.base.discrete">
<span id="base-discrete-agent-abstract"></span><h2>Base Discrete Agent (abstract)<a class="headerlink" href="#module-mantrap.agents.base.discrete" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="mantrap.agents.base.discrete.DTAgent">
<em class="property">class </em><code class="sig-prename descclassname">mantrap.agents.base.discrete.</code><code class="sig-name descname">DTAgent</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">position</span><span class="p">:</span> <span class="n">torch.Tensor</span></em>, <em class="sig-param"><span class="n">velocity</span><span class="p">:</span> <span class="n">torch.Tensor</span> <span class="o">=</span> <span class="default_value">tensor([0.0, 0.0])</span></em>, <em class="sig-param"><span class="n">time</span><span class="p">:</span> <span class="n">float</span> <span class="o">=</span> <span class="default_value">0</span></em>, <em class="sig-param"><span class="n">history</span><span class="p">:</span> <span class="n">torch.Tensor</span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">is_robot</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">identifier</span><span class="p">:</span> <span class="n">str</span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">unused</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mantrap.agents.base.discrete.DTAgent" title="Permalink to this definition">¶</a></dt>
<dd><p>General agent representation.</p>
<p>An agent, whether in environment or real world, has a five-dimensional state vector and a state history, which are
defined as follows:</p>
<div class="math notranslate nohighlight">
\[s_t = (pos_x(t), pos_y(t), vel_x(t), vel_y(t), time)\]</div>
<div class="math notranslate nohighlight">
\[history = (s_{t0}, s_{t1}, ..., s_{t})\]</div>
<p>For unique identification each agent has an id (3-character string) and for visualisation purposes a unique color.
Both are created randomly during initialization.</p>
<p>The internal state of the agent can be altered by calling the <cite>update()</cite> function, which uses some (control) input
to update the agent’s state using its dynamics, or the <cite>reset()</cite> function, which sets the internal state to some
value directly. All other methods do not alter the internal state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>position</strong> – current 2D position vector (2).</p></li>
<li><p><strong>velocity</strong> – current 2D velocity vector (2).</p></li>
<li><p><strong>time</strong> – current time stamp, default = 0.0.</p></li>
<li><p><strong>history</strong> – current agent’s state history (N, 5), default = no history.</p></li>
<li><p><strong>identifier</strong> – agent’s pre-set identifier, default = none so initialized randomly during initialization.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="mantrap.agents.base.discrete.DTAgent.check_feasibility_controls">
<code class="sig-name descname">check_feasibility_controls</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">controls</span><span class="p">:</span> <span class="n">torch.Tensor</span></em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#mantrap.agents.base.discrete.DTAgent.check_feasibility_controls" title="Permalink to this definition">¶</a></dt>
<dd><p>Check feasibility of a given set of controls to be executed by the internal agent.</p>
<p>In order to check feasibility convert the trajectory just check whether the controls
are inside the internal control boundaries. Since changes of control input from one
step to another are not limited, they are not checked here.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>controls</strong> – controls to be checked (N, 2).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mantrap.agents.base.discrete.DTAgent.check_feasibility_trajectory">
<code class="sig-name descname">check_feasibility_trajectory</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">trajectory</span><span class="p">:</span> <span class="n">torch.Tensor</span></em>, <em class="sig-param"><span class="n">dt</span><span class="p">:</span> <span class="n">float</span></em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#mantrap.agents.base.discrete.DTAgent.check_feasibility_trajectory" title="Permalink to this definition">¶</a></dt>
<dd><p>Check feasibility of a given trajectory to be followed by the internal agent.</p>
<p>In order to check feasibility convert the trajectory to control inputs using the
internal inverse dynamics of the agent and check whether all of them are inside
its control boundaries.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>trajectory</strong> – trajectory to be checked (N, 4).</p></li>
<li><p><strong>dt</strong> – time interval [s] between discrete trajectory states.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mantrap.agents.base.discrete.DTAgent.control_limits">
<em class="property">abstract </em><code class="sig-name descname">control_limits</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; Tuple<span class="p">[</span>float<span class="p">, </span>float<span class="p">]</span><a class="headerlink" href="#mantrap.agents.base.discrete.DTAgent.control_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns agent’s control input limitations, i.e. lower and upper bound.</p>
</dd></dl>

<dl class="py method">
<dt id="mantrap.agents.base.discrete.DTAgent.detach">
<code class="sig-name descname">detach</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mantrap.agents.base.discrete.DTAgent.detach" title="Permalink to this definition">¶</a></dt>
<dd><p>Detach the agent’s internal variables (position, velocity, history) from computation tree. This is
sometimes required to completely separate subsequent computations in PyTorch.</p>
</dd></dl>

<dl class="py method">
<dt id="mantrap.agents.base.discrete.DTAgent.dx_du">
<em class="property">abstract </em><code class="sig-name descname">dx_du</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">controls</span><span class="p">:</span> <span class="n">torch.Tensor</span></em>, <em class="sig-param"><span class="n">dt</span><span class="p">:</span> <span class="n">float</span></em><span class="sig-paren">)</span> &#x2192; torch.Tensor<a class="headerlink" href="#mantrap.agents.base.discrete.DTAgent.dx_du" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the derivative of the agent’s state with respect to its control input
evaluated over controls u with discrete state time-step dt.</p>
</dd></dl>

<dl class="py method">
<dt id="mantrap.agents.base.discrete.DTAgent.dynamics">
<code class="sig-name descname">dynamics</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">state</span><span class="p">:</span> <span class="n">torch.Tensor</span></em>, <em class="sig-param"><span class="n">action</span><span class="p">:</span> <span class="n">torch.Tensor</span></em>, <em class="sig-param"><span class="n">dt</span><span class="p">:</span> <span class="n">float</span></em><span class="sig-paren">)</span> &#x2192; torch.Tensor<a class="headerlink" href="#mantrap.agents.base.discrete.DTAgent.dynamics" title="Permalink to this definition">¶</a></dt>
<dd><p>Forward integrate the agent’s motion given some state-action pair and an integration time-step.</p>
<p>Passing the state, instead of using the internal state, allows the method to be used for other state
vector than the internal state, e.g. for forward predicting over a time horizon &gt; 1. Since every agent
type has different dynamics (like single-integrator or Dubins Car) this method is implemented abstractly.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state</strong> – state to be updated &#64; t = k (5).</p></li>
<li><p><strong>action</strong> – control input &#64; t = k (size depending on agent type).</p></li>
<li><p><strong>dt</strong> – forward integration time step [s].</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>updated state vector with time &#64; t = k + dt (5).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mantrap.agents.base.discrete.DTAgent.dynamics_scalar">
<em class="property">static </em><code class="sig-name descname">dynamics_scalar</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">px</span><span class="p">:</span> <span class="n">float</span></em>, <em class="sig-param"><span class="n">py</span><span class="p">:</span> <span class="n">float</span></em>, <em class="sig-param"><span class="n">vx</span><span class="p">:</span> <span class="n">float</span></em>, <em class="sig-param"><span class="n">vy</span><span class="p">:</span> <span class="n">float</span></em>, <em class="sig-param"><span class="n">ux</span><span class="p">:</span> <span class="n">float</span></em>, <em class="sig-param"><span class="n">uy</span><span class="p">:</span> <span class="n">float</span></em>, <em class="sig-param"><span class="n">dt</span><span class="p">:</span> <span class="n">float</span></em><span class="sig-paren">)</span> &#x2192; Tuple<span class="p">[</span>float<span class="p">, </span>float<span class="p">, </span>float<span class="p">, </span>float<span class="p">]</span><a class="headerlink" href="#mantrap.agents.base.discrete.DTAgent.dynamics_scalar" title="Permalink to this definition">¶</a></dt>
<dd><p>Forward integrate the agent’s motion given some state-action pair and an integration time-step.</p>
<p>In comparison to the “normal” dynamics() method this method can be used for repeated scalar and non-
differentiable use cases. Since the agent’s fundamental state tensor operations are “only” two-dimensional
using tensor arithmetic rather creates an overhead, instead of saving computational effort, compared to
native python scalar operations.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>position x, position y, velocity x, velocity y of new state</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mantrap.agents.base.discrete.DTAgent.expand_state_vector">
<em class="property">static </em><code class="sig-name descname">expand_state_vector</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">state_4</span><span class="p">:</span> <span class="n">torch.Tensor</span></em>, <em class="sig-param"><span class="n">time</span><span class="p">:</span> <span class="n">float</span></em><span class="sig-paren">)</span> &#x2192; torch.Tensor<a class="headerlink" href="#mantrap.agents.base.discrete.DTAgent.expand_state_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Expand 4 dimensional (x, y, vx, vy) state vector by time information.</p>
</dd></dl>

<dl class="py method">
<dt id="mantrap.agents.base.discrete.DTAgent.expand_trajectory">
<code class="sig-name descname">expand_trajectory</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span><span class="p">:</span> <span class="n">torch.Tensor</span></em>, <em class="sig-param"><span class="n">dt</span><span class="p">:</span> <span class="n">float</span></em><span class="sig-paren">)</span> &#x2192; torch.Tensor<a class="headerlink" href="#mantrap.agents.base.discrete.DTAgent.expand_trajectory" title="Permalink to this definition">¶</a></dt>
<dd><p>Derive (position, orientation, velocity)-trajectory information from position data only, using naive
discrete differentiation, i.e. v_i = (x_i+1 - x_i) / dt.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path</strong> – sequence of states (position, velocity) without temporal dimension (N, 4).</p></li>
<li><p><strong>dt</strong> – time interval which is assumed to be constant over full path sequence [s].</p></li>
</ul>
</dd>
<dt class="field-even">Returns trajectory</dt>
<dd class="field-even"><p>temporally-expanded path (N, 5).s</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mantrap.agents.base.discrete.DTAgent.go_to_point">
<em class="property">abstract </em><code class="sig-name descname">go_to_point</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">state</span><span class="p">:</span> <span class="n">Tuple<span class="p">[</span>float<span class="p">, </span>float<span class="p">, </span>float<span class="p">, </span>float<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">target_point</span><span class="p">:</span> <span class="n">Tuple<span class="p">[</span>float<span class="p">, </span>float<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">speed</span><span class="p">:</span> <span class="n">float</span></em>, <em class="sig-param"><span class="n">dt</span><span class="p">:</span> <span class="n">float</span></em><span class="sig-paren">)</span> &#x2192; Tuple<span class="p">[</span>Tuple<span class="p">[</span>float<span class="p">, </span>float<span class="p">, </span>float<span class="p">, </span>float<span class="p">]</span><span class="p">, </span>Tuple<span class="p">[</span>float<span class="p">, </span>float<span class="p">]</span><span class="p">]</span><a class="headerlink" href="#mantrap.agents.base.discrete.DTAgent.go_to_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine and execute the controls for going for the given state to some target point with respect
to the internal dynamics.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state</strong> – pos_and_vel_only state vector i.e. (px, py, vx, vy) for starting state.</p></li>
<li><p><strong>target_point</strong> – 2D target point (px, py).</p></li>
<li><p><strong>speed</strong> – preferable speed for state update [m/s].</p></li>
<li><p><strong>dt</strong> – update time interval [s].</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>updated state at t = t0 + dt and used (cardinal) control input.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mantrap.agents.base.discrete.DTAgent.inverse_dynamics">
<code class="sig-name descname">inverse_dynamics</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">state</span><span class="p">:</span> <span class="n">torch.Tensor</span></em>, <em class="sig-param"><span class="n">state_previous</span><span class="p">:</span> <span class="n">torch.Tensor</span></em>, <em class="sig-param"><span class="n">dt</span><span class="p">:</span> <span class="n">float</span></em><span class="sig-paren">)</span> &#x2192; torch.Tensor<a class="headerlink" href="#mantrap.agents.base.discrete.DTAgent.inverse_dynamics" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the agent’s motion given its current and previous state.</p>
<p>Passing the state, instead of using the internal state, allows the method to be used for other state
vector than the internal state, e.g. for forward predicting over a time horizon &gt; 1. Since every agent
type has different dynamics (like single-integrator or Dubins Car) this method is implemented abstractly.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state</strong> – state &#64; t = k (4 or 5).</p></li>
<li><p><strong>state_previous</strong> – previous state &#64; t = k - dt (4 or 5).</p></li>
<li><p><strong>dt</strong> – forward integration time step [s].</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>control input &#64; t = k (size depending on agent type).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mantrap.agents.base.discrete.DTAgent.make_controls_feasible">
<code class="sig-name descname">make_controls_feasible</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">controls</span><span class="p">:</span> <span class="n">torch.Tensor</span></em><span class="sig-paren">)</span> &#x2192; torch.Tensor<a class="headerlink" href="#mantrap.agents.base.discrete.DTAgent.make_controls_feasible" title="Permalink to this definition">¶</a></dt>
<dd><p>Make controls feasible by clipping them between its lower and upper boundaries.</p>
<p>Return the transformed feasible controls. The direction of controls is thereby not changed, since
just the length of the control vector is adapted. If the controls are just zeros then return
them as they are.</p>
</dd></dl>

<dl class="py method">
<dt id="mantrap.agents.base.discrete.DTAgent.make_controls_feasible_scalar">
<code class="sig-name descname">make_controls_feasible_scalar</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">control_x</span><span class="p">:</span> <span class="n">float</span></em>, <em class="sig-param"><span class="n">control_y</span><span class="p">:</span> <span class="n">float</span></em><span class="sig-paren">)</span> &#x2192; Tuple<span class="p">[</span>float<span class="p">, </span>float<span class="p">]</span><a class="headerlink" href="#mantrap.agents.base.discrete.DTAgent.make_controls_feasible_scalar" title="Permalink to this definition">¶</a></dt>
<dd><p>Make single control feasible by clipping them between its lower and upper boundaries. Return
the transformed feasible controls. Since this is basically clamping each direction separately,
the overall direction of the control input might be changed !!</p>
</dd></dl>

<dl class="py method">
<dt id="mantrap.agents.base.discrete.DTAgent.reachability_boundary">
<em class="property">abstract </em><code class="sig-name descname">reachability_boundary</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">time_steps</span><span class="p">:</span> <span class="n">int</span></em>, <em class="sig-param"><span class="n">dt</span><span class="p">:</span> <span class="n">float</span></em><span class="sig-paren">)</span> &#x2192; mantrap.utility.maths.Shape2D<a class="headerlink" href="#mantrap.agents.base.discrete.DTAgent.reachability_boundary" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the forward reachable set within the time-horizon with <cite>time_steps</cite> number of discrete
steps with time-step <cite>dt</cite>. While the reachable set can be computed numerically in general, an
exact (and more efficient) implementation has to be done in the child classes. Return this exact
solution as class object of <cite>Shape2D</cite> type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>time_steps</strong> – number of discrete time-steps in reachable time-horizon.</p></li>
<li><p><strong>dt</strong> – time interval which is assumed to be constant over full path sequence [s].</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mantrap.agents.base.discrete.DTAgent.reset">
<code class="sig-name descname">reset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">state</span><span class="p">:</span> <span class="n">torch.Tensor</span></em>, <em class="sig-param"><span class="n">history</span><span class="p">:</span> <span class="n">torch.Tensor</span> <span class="o">=</span> <span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mantrap.agents.base.discrete.DTAgent.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset the complete state of the agent by resetting its position and velocity. Either adapt the agent’s
history to the new state (i.e. append it to the already existing history) if history is given as None or set
it to some given trajectory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state</strong> – new state (5).</p></li>
<li><p><strong>history</strong> – new state history (N, 5).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mantrap.agents.base.discrete.DTAgent.roll_trajectory">
<code class="sig-name descname">roll_trajectory</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">trajectory</span><span class="p">:</span> <span class="n">torch.Tensor</span></em>, <em class="sig-param"><span class="n">dt</span><span class="p">:</span> <span class="n">float</span></em><span class="sig-paren">)</span> &#x2192; torch.Tensor<a class="headerlink" href="#mantrap.agents.base.discrete.DTAgent.roll_trajectory" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the controls by iteratively applying the agent’s model inverse dynamics.
Thereby a perfect model i.e. without uncertainty and correct is assumed.</p>
<p>To guarantee that the unrolled trajectory is invertible, i.e. when the resulting trajectory is
back-transformed to the controls, the same controls should occur. Therefore no checks for the
feasibility of the controls are made. Also this function is not updating the agent in fact,
it is rather determining the theoretical trajectory given the agent’s dynamics and controls.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>trajectory</strong> – sequence of states to apply to the robot (N, 4).</p></li>
<li><p><strong>dt</strong> – time interval [s] between discrete trajectory states.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>inferred controls (no uncertainty in dynamics assumption !), (N, input_size).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mantrap.agents.base.discrete.DTAgent.sanity_check">
<code class="sig-name descname">sanity_check</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#mantrap.agents.base.discrete.DTAgent.sanity_check" title="Permalink to this definition">¶</a></dt>
<dd><p>Sanity check for agent.
In order to evaluate the sanity of the agent in the most general form, several internal states such as the
position and velocity are checked to be of the right type. Also the history should always reflect the
states until and including (!) the current state.</p>
</dd></dl>

<dl class="py method">
<dt id="mantrap.agents.base.discrete.DTAgent.unroll_trajectory">
<code class="sig-name descname">unroll_trajectory</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">controls</span><span class="p">:</span> <span class="n">torch.Tensor</span></em>, <em class="sig-param"><span class="n">dt</span><span class="p">:</span> <span class="n">float</span></em><span class="sig-paren">)</span> &#x2192; torch.Tensor<a class="headerlink" href="#mantrap.agents.base.discrete.DTAgent.unroll_trajectory" title="Permalink to this definition">¶</a></dt>
<dd><p>Build the trajectory from some controls and current state, by iteratively applying the model
dynamics. Thereby a perfect model i.e. without uncertainty and correct is assumed.</p>
<p>To guarantee that the unrolled trajectory is invertible, i.e. when the resulting trajectory is
back-transformed to the controls, the same controls should occur. Therefore no checks for the
feasibility of the controls are made. Also this function is not updating the agent in fact,
it is rather determining the theoretical trajectory given the agent’s dynamics and controls.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>controls</strong> – sequence of inputs to apply to the robot (N, input_size).</p></li>
<li><p><strong>dt</strong> – time interval [s] between discrete trajectory states.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>resulting trajectory (no uncertainty in dynamics assumption !), (N, 4).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mantrap.agents.base.discrete.DTAgent.update">
<code class="sig-name descname">update</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">action</span><span class="p">:</span> <span class="n">torch.Tensor</span></em>, <em class="sig-param"><span class="n">dt</span><span class="p">:</span> <span class="n">float</span></em><span class="sig-paren">)</span> &#x2192; Tuple<span class="p">[</span>torch.Tensor<span class="p">, </span>torch.Tensor<span class="p">]</span><a class="headerlink" href="#mantrap.agents.base.discrete.DTAgent.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update internal state (position, velocity and history) by forward integrating the agent’s dynamics over
the given time-step. The new state and time are then appended to the agent’s state history.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>action</strong> – control input (size depending on agent type).</p></li>
<li><p><strong>dt</strong> – forward integration time step [s].</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>executed control action and new agent state</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-mantrap.agents.base.linear">
<span id="linear-agents"></span><h2>Linear Agents<a class="headerlink" href="#module-mantrap.agents.base.linear" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="mantrap.agents.base.linear.LinearDTAgent">
<em class="property">class </em><code class="sig-prename descclassname">mantrap.agents.base.linear.</code><code class="sig-name descname">LinearDTAgent</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">position</span><span class="p">:</span> <span class="n">torch.Tensor</span></em>, <em class="sig-param"><span class="n">velocity</span><span class="p">:</span> <span class="n">torch.Tensor</span> <span class="o">=</span> <span class="default_value">tensor([0.0, 0.0])</span></em>, <em class="sig-param"><span class="n">history</span><span class="p">:</span> <span class="n">torch.Tensor</span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dt</span><span class="p">:</span> <span class="n">float</span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">max_steps</span><span class="p">:</span> <span class="n">int</span> <span class="o">=</span> <span class="default_value">20</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">agent_kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mantrap.agents.base.linear.LinearDTAgent" title="Permalink to this definition">¶</a></dt>
<dd><p>Intermediate agent class for agents having linear state dynamics.</p>
<p>For linear state dynamics the dynamics can be computed very efficiently, using matrix-vector multiplication,
with constant matrices (state-space matrices).</p>
<div class="math notranslate nohighlight">
\[x_{i + n} = A^n x_i + \sum_{k=0}^{n-1} A^{n-k-1} * B * u_{i+k}\]</div>
<p>Passing the simulation time-step directly instead of passing it to every function individually surely is not
nice, but it enables pre-computing of the agent’s dynamics matrices, which speeds up computation of the dynamics
by at least factor 5 (see examples/tools/timing), especially since the dynamics() method is the most called
function in the full program. As storing the same information twice generally a bad programming paradigm and
it reduces the capabilities of the controller a lot to only be able to handle one time-step, as a trade-off
solution a dictionary of dynamics matrices is built, enabling handling multiple time-steps but still computing them
once only.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dt</strong> – default dynamics time-step [s], default none (no dynamics pre-computation).</p></li>
<li><p><strong>max_steps</strong> – maximal number of pre-computed rolling steps.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="mantrap.agents.base.linear.LinearDTAgent.dx_du">
<code class="sig-name descname">dx_du</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">controls</span><span class="p">:</span> <span class="n">torch.Tensor</span></em>, <em class="sig-param"><span class="n">dt</span><span class="p">:</span> <span class="n">float</span></em><span class="sig-paren">)</span> &#x2192; torch.Tensor<a class="headerlink" href="#mantrap.agents.base.linear.LinearDTAgent.dx_du" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the derivative of the agent’s control input with respect to its
state, evaluated over state trajectory x with discrete state time-step dt.</p>
<p>As follows from the equations for some state at time-step n <cite>x_n</cite> in dependence of
the initial state <cite>x0</cite> and the control inputs <cite>u_k</cite>, we have</p>
<p>due to the assumptions that the control inputs are independently from each other,
their derivatives do not depend on each other, i.e. <cite>du_i/du_j = 0 for all i != j</cite>.
Also the state at time-step n only depends on the initial state and the control
inputs, not the states in between when the equation above is used !
Therefore we can simplify the equation above to the following:</p>
</dd></dl>

<dl class="py method">
<dt id="mantrap.agents.base.linear.LinearDTAgent.reachability_boundary">
<code class="sig-name descname">reachability_boundary</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">time_steps</span><span class="p">:</span> <span class="n">int</span></em>, <em class="sig-param"><span class="n">dt</span><span class="p">:</span> <span class="n">float</span></em><span class="sig-paren">)</span> &#x2192; mantrap.utility.maths.Circle<a class="headerlink" href="#mantrap.agents.base.linear.LinearDTAgent.reachability_boundary" title="Permalink to this definition">¶</a></dt>
<dd><p>Generally for linear agents the N-th can be easily expressed in terms of the controls and the
initial state by nesting the linear dynamics, resulting in</p>
<div class="math notranslate nohighlight">
\[x_{i + N} = A^N x_i + \sum_{k = 0}^{N - 1} A^{N - k - 1} B u_{i + k}\]</div>
<p>Also linear agents are assumed to behave isotropic (here), i.e. the control input can change its direction
instantly and without limitation. Therefore the forward reachable set within the number of time_steps is
just a circle (in general ellipse, but agent has same control bounds for both x- and y-direction) around
the current position, with radius being the maximal allowed agent speed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>time_steps</strong> – number of discrete time-steps in reachable time-horizon.</p></li>
<li><p><strong>dt</strong> – time interval which is assumed to be constant over full path sequence [s].</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mantrap.agents.base.linear.LinearDTAgent.roll_trajectory">
<code class="sig-name descname">roll_trajectory</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">trajectory</span><span class="p">:</span> <span class="n">torch.Tensor</span></em>, <em class="sig-param"><span class="n">dt</span><span class="p">:</span> <span class="n">float</span></em><span class="sig-paren">)</span> &#x2192; torch.Tensor<a class="headerlink" href="#mantrap.agents.base.linear.LinearDTAgent.roll_trajectory" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the controls by iteratively applying the agent’s model inverse dynamics.
Thereby a perfect model i.e. without uncertainty and correct is assumed.</p>
<p>To guarantee that the unrolled trajectory is invertible, i.e. when the resulting trajectory is
back-transformed to the controls, the same controls should occur. Therefore no checks for the
feasibility of the controls are made. Also this function is not updating the agent in fact,
it is rather determining the theoretical trajectory given the agent’s dynamics and controls.</p>
<p>For linear agents determining the controls from the trajectory is very straight-forward and
most importantly does not have to be done sequentially (at least not for the types of agents
used within this project). Therefore the <cite>roll_trajectory()</cite> method can be improved.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>trajectory</strong> – sequence of states to apply to the robot (N, 4).</p></li>
<li><p><strong>dt</strong> – time interval [s] between discrete trajectory states.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>inferred controls (no uncertainty in dynamics assumption !), (N, input_size).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mantrap.agents.base.linear.LinearDTAgent.unroll_trajectory">
<code class="sig-name descname">unroll_trajectory</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">controls</span><span class="p">:</span> <span class="n">torch.Tensor</span></em>, <em class="sig-param"><span class="n">dt</span><span class="p">:</span> <span class="n">float</span></em><span class="sig-paren">)</span> &#x2192; torch.Tensor<a class="headerlink" href="#mantrap.agents.base.linear.LinearDTAgent.unroll_trajectory" title="Permalink to this definition">¶</a></dt>
<dd><p>Build the trajectory from some controls and current state, by iteratively applying the model
dynamics. Thereby a perfect model i.e. without uncertainty and correct is assumed.</p>
<p>To guarantee that the unrolled trajectory is invertible, i.e. when the resulting trajectory is
back-transformed to the controls, the same controls should occur. Therefore no checks for the
feasibility of the controls are made. Also this function is not updating the agent in fact,
it is rather determining the theoretical trajectory given the agent’s dynamics and controls.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>controls</strong> – sequence of inputs to apply to the robot (N, input_size).</p></li>
<li><p><strong>dt</strong> – time interval [s] between discrete trajectory states.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>resulting trajectory (no uncertainty in dynamics assumption !), (N, 4).</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<div class="section" id="module-mantrap.agents.integrator_single">
<span id="single-integrator"></span><h3>Single Integrator<a class="headerlink" href="#module-mantrap.agents.integrator_single" title="Permalink to this headline">¶</a></h3>
<dl class="py class">
<dt id="mantrap.agents.integrator_single.IntegratorDTAgent">
<em class="property">class </em><code class="sig-prename descclassname">mantrap.agents.integrator_single.</code><code class="sig-name descname">IntegratorDTAgent</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">position</span><span class="p">:</span> <span class="n">torch.Tensor</span></em>, <em class="sig-param"><span class="n">velocity</span><span class="p">:</span> <span class="n">torch.Tensor</span> <span class="o">=</span> <span class="default_value">tensor([0.0, 0.0])</span></em>, <em class="sig-param"><span class="n">history</span><span class="p">:</span> <span class="n">torch.Tensor</span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dt</span><span class="p">:</span> <span class="n">float</span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">max_steps</span><span class="p">:</span> <span class="n">int</span> <span class="o">=</span> <span class="default_value">20</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">agent_kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mantrap.agents.integrator_single.IntegratorDTAgent" title="Permalink to this definition">¶</a></dt>
<dd><p>Linear single integrator dynamics:</p>
<div class="math notranslate nohighlight">
\[vel_{t+1} = action\]</div>
<div class="math notranslate nohighlight">
\[pos_{t+1} = pos_t + vel_{t+1} * dt\]</div>
<dl class="py method">
<dt id="mantrap.agents.integrator_single.IntegratorDTAgent.acceleration_max">
<em class="property">property </em><code class="sig-name descname">acceleration_max</code><a class="headerlink" href="#mantrap.agents.integrator_single.IntegratorDTAgent.acceleration_max" title="Permalink to this definition">¶</a></dt>
<dd><p>Since single integrators are assumed to react instantly, their maximal acceleration
is in fact infinite !</p>
</dd></dl>

<dl class="py method">
<dt id="mantrap.agents.integrator_single.IntegratorDTAgent.control_limits">
<code class="sig-name descname">control_limits</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; Tuple<span class="p">[</span>float<span class="p">, </span>float<span class="p">]</span><a class="headerlink" href="#mantrap.agents.integrator_single.IntegratorDTAgent.control_limits" title="Permalink to this definition">¶</a></dt>
<dd><div class="math notranslate nohighlight">
\[[- v_{max}, v_{max}]\]</div>
</dd></dl>

<dl class="py method">
<dt id="mantrap.agents.integrator_single.IntegratorDTAgent.dynamics_scalar">
<em class="property">static </em><code class="sig-name descname">dynamics_scalar</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">px</span><span class="p">:</span> <span class="n">float</span></em>, <em class="sig-param"><span class="n">py</span><span class="p">:</span> <span class="n">float</span></em>, <em class="sig-param"><span class="n">vx</span><span class="p">:</span> <span class="n">float</span></em>, <em class="sig-param"><span class="n">vy</span><span class="p">:</span> <span class="n">float</span></em>, <em class="sig-param"><span class="n">ux</span><span class="p">:</span> <span class="n">float</span></em>, <em class="sig-param"><span class="n">uy</span><span class="p">:</span> <span class="n">float</span></em>, <em class="sig-param"><span class="n">dt</span><span class="p">:</span> <span class="n">float</span></em><span class="sig-paren">)</span> &#x2192; Tuple<span class="p">[</span>float<span class="p">, </span>float<span class="p">, </span>float<span class="p">, </span>float<span class="p">]</span><a class="headerlink" href="#mantrap.agents.integrator_single.IntegratorDTAgent.dynamics_scalar" title="Permalink to this definition">¶</a></dt>
<dd><p>Forward integrate the agent’s motion given some state-action pair and an integration time-step.</p>
<p>In comparison to the “normal” dynamics() method this method can be used for repeated scalar and non-
differentiable use cases. Since the agent’s fundamental state tensor operations are “only” two-dimensional
using tensor arithmetic rather creates an overhead, instead of saving computational effort, compared to
native python scalar operations.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>position x, position y, velocity x, velocity y of new state</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mantrap.agents.integrator_single.IntegratorDTAgent.go_to_point">
<code class="sig-name descname">go_to_point</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">state</span><span class="p">:</span> <span class="n">Tuple<span class="p">[</span>float<span class="p">, </span>float<span class="p">, </span>float<span class="p">, </span>float<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">target_point</span><span class="p">:</span> <span class="n">Tuple<span class="p">[</span>float<span class="p">, </span>float<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">speed</span><span class="p">:</span> <span class="n">float</span></em>, <em class="sig-param"><span class="n">dt</span><span class="p">:</span> <span class="n">float</span></em><span class="sig-paren">)</span> &#x2192; Tuple<span class="p">[</span>Tuple<span class="p">[</span>float<span class="p">, </span>float<span class="p">, </span>float<span class="p">, </span>float<span class="p">]</span><span class="p">, </span>Tuple<span class="p">[</span>float<span class="p">, </span>float<span class="p">]</span><span class="p">]</span><a class="headerlink" href="#mantrap.agents.integrator_single.IntegratorDTAgent.go_to_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine and execute the controls for going for the given state to some target point with respect to
the internal dynamics.</p>
<p>Due to the instant dynamics of a single integrator going from one point to another simple means instantly
adapting the controls to go in the right direction.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state</strong> – pos_and_vel_only state vector i.e. (px, py, vx, vy) for starting state.</p></li>
<li><p><strong>target_point</strong> – 2D target point (px, py).</p></li>
<li><p><strong>speed</strong> – preferable speed for state update [m/s].</p></li>
<li><p><strong>dt</strong> – update time interval [s].</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>updated state at t = t0 + dt and used (cardinal) control input.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-mantrap.agents.integrator_double">
<span id="double-integrator"></span><h3>Double Integrator<a class="headerlink" href="#module-mantrap.agents.integrator_double" title="Permalink to this headline">¶</a></h3>
<dl class="py class">
<dt id="mantrap.agents.integrator_double.DoubleIntegratorDTAgent">
<em class="property">class </em><code class="sig-prename descclassname">mantrap.agents.integrator_double.</code><code class="sig-name descname">DoubleIntegratorDTAgent</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">position</span><span class="p">:</span> <span class="n">torch.Tensor</span></em>, <em class="sig-param"><span class="n">velocity</span><span class="p">:</span> <span class="n">torch.Tensor</span> <span class="o">=</span> <span class="default_value">tensor([0.0, 0.0])</span></em>, <em class="sig-param"><span class="n">history</span><span class="p">:</span> <span class="n">torch.Tensor</span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dt</span><span class="p">:</span> <span class="n">float</span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">max_steps</span><span class="p">:</span> <span class="n">int</span> <span class="o">=</span> <span class="default_value">20</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">agent_kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mantrap.agents.integrator_double.DoubleIntegratorDTAgent" title="Permalink to this definition">¶</a></dt>
<dd><p>Linear double integrator dynamics:</p>
<div class="math notranslate nohighlight">
\[vel_{t+1} = vel_t + action * dt\]</div>
<div class="math notranslate nohighlight">
\[pos_{t+1} = pos_t + vel_{t+1} * dt\]</div>
<dl class="py method">
<dt id="mantrap.agents.integrator_double.DoubleIntegratorDTAgent.control_limits">
<code class="sig-name descname">control_limits</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; Tuple<span class="p">[</span>float<span class="p">, </span>float<span class="p">]</span><a class="headerlink" href="#mantrap.agents.integrator_double.DoubleIntegratorDTAgent.control_limits" title="Permalink to this definition">¶</a></dt>
<dd><div class="math notranslate nohighlight">
\[[- a_{max}, a_{max}]\]</div>
</dd></dl>

<dl class="py method">
<dt id="mantrap.agents.integrator_double.DoubleIntegratorDTAgent.dynamics_scalar">
<em class="property">static </em><code class="sig-name descname">dynamics_scalar</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">px</span><span class="p">:</span> <span class="n">float</span></em>, <em class="sig-param"><span class="n">py</span><span class="p">:</span> <span class="n">float</span></em>, <em class="sig-param"><span class="n">vx</span><span class="p">:</span> <span class="n">float</span></em>, <em class="sig-param"><span class="n">vy</span><span class="p">:</span> <span class="n">float</span></em>, <em class="sig-param"><span class="n">ux</span><span class="p">:</span> <span class="n">float</span></em>, <em class="sig-param"><span class="n">uy</span><span class="p">:</span> <span class="n">float</span></em>, <em class="sig-param"><span class="n">dt</span><span class="p">:</span> <span class="n">float</span></em><span class="sig-paren">)</span> &#x2192; Tuple<span class="p">[</span>float<span class="p">, </span>float<span class="p">, </span>float<span class="p">, </span>float<span class="p">]</span><a class="headerlink" href="#mantrap.agents.integrator_double.DoubleIntegratorDTAgent.dynamics_scalar" title="Permalink to this definition">¶</a></dt>
<dd><p>Forward integrate the agent’s motion given some state-action pair and an integration time-step.</p>
<p>In comparison to the “normal” dynamics() method this method can be used for repeated scalar and non-
differentiable use cases. Since the agent’s fundamental state tensor operations are “only” two-dimensional
using tensor arithmetic rather creates an overhead, instead of saving computational effort, compared to
native python scalar operations.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>position x, position y, velocity x, velocity y of new state</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mantrap.agents.integrator_double.DoubleIntegratorDTAgent.go_to_point">
<code class="sig-name descname">go_to_point</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">state</span><span class="p">:</span> <span class="n">Tuple<span class="p">[</span>float<span class="p">, </span>float<span class="p">, </span>float<span class="p">, </span>float<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">target_point</span><span class="p">:</span> <span class="n">Tuple<span class="p">[</span>float<span class="p">, </span>float<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">speed</span><span class="p">:</span> <span class="n">float</span></em>, <em class="sig-param"><span class="n">dt</span><span class="p">:</span> <span class="n">float</span></em>, <em class="sig-param"><span class="n">pseudo_wheel_distance</span><span class="p">:</span> <span class="n">float</span> <span class="o">=</span> <span class="default_value">0.05</span></em>, <em class="sig-param"><span class="n">k_speed</span><span class="p">:</span> <span class="n">float</span> <span class="o">=</span> <span class="default_value">1.0</span></em><span class="sig-paren">)</span> &#x2192; Tuple<span class="p">[</span>Tuple<span class="p">[</span>float<span class="p">, </span>float<span class="p">, </span>float<span class="p">, </span>float<span class="p">]</span><span class="p">, </span>Tuple<span class="p">[</span>float<span class="p">, </span>float<span class="p">]</span><span class="p">]</span><a class="headerlink" href="#mantrap.agents.integrator_double.DoubleIntegratorDTAgent.go_to_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine and execute the controls for going for the given state to some target point with respect to
the internal dynamics.</p>
<p>For from some point to another the double integrator uses a variant of pure pursuit control, which basically
means, that it is not treated as a point mass but as a vehicle/car with very small width
(<cite>pseudo_wheel_distance</cite>). Then the required acceleration and steering commands can be computed for the
given scenario and transformed to the cartesian controls the double integrator requires.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state</strong> – pos_and_vel_only state vector i.e. (px, py, vx, vy) for starting state.</p></li>
<li><p><strong>target_point</strong> – 2D target point (px, py).</p></li>
<li><p><strong>speed</strong> – preferable speed for state update [m/s].</p></li>
<li><p><strong>dt</strong> – update time interval [s].</p></li>
<li><p><strong>pseudo_wheel_distance</strong> – distance between imaginary wheels [m].</p></li>
<li><p><strong>k_speed</strong> – speed control gain.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>updated state at t = t0 + dt and used (cardinal) control input.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Agents</a><ul>
<li><a class="reference internal" href="#module-mantrap.agents.base.discrete">Base Discrete Agent (abstract)</a></li>
<li><a class="reference internal" href="#module-mantrap.agents.base.linear">Linear Agents</a><ul>
<li><a class="reference internal" href="#module-mantrap.agents.integrator_single">Single Integrator</a></li>
<li><a class="reference internal" href="#module-mantrap.agents.integrator_double">Double Integrator</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">mantrap</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="environment.html"
                        title="next chapter">Environment</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/agents.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="environment.html" title="Environment"
             >next</a> |</li>
        <li class="right" >
          <a href="index.html" title="mantrap"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">mantrap 0.1 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, Simon Schaefer.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.0.3.
    </div>
  </body>
</html>